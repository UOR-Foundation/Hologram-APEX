---
title: "WASM Deployment Guide for Hologram Model Server"
description: "WASM Deployment Guide for Hologram Model Server documentation"
---

# WASM Deployment Guide for Hologram Model Server

This guide explains how to compile the Hologram Model Server to WebAssembly (WASM) and deploy it for use in web browsers or Node.js applications.

## Prerequisites

### 1. Install Rust with WASM Support

```bash
# Install Rust (if not already installed)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Add WASM target
rustup target add wasm32-unknown-unknown
rustup target add wasm32-wasi

# Install wasm-bindgen CLI
cargo install wasm-bindgen-cli

# Install wasm-pack (optional, for npm package generation)
curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh
```

### 2. Install Node.js and npm

```bash
# Install Node.js 18 or later
# Visit https://nodejs.org/ or use nvm:
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
nvm install 18
nvm use 18
```

## Building for WASM

### Option 1: Using wasm-pack (Recommended)

**Step 1**: Create a `Cargo.toml` configuration for WASM:

```toml
[package]
name = "hologram-model-server-wasm"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
hologram-ffi = { path = "../../crates/hologram-ffi", features = ["model-server"] }
wasm-bindgen = "0.2"
serde-wasm-bindgen = "0.6"
console_error_panic_hook = "0.1"

[dev-dependencies]
wasm-bindgen-test = "0.3"

[profile.release]
opt-level = "z"     # Optimize for size
lto = true          # Enable Link Time Optimization
codegen-units = 1   # Reduce number of codegen units to increase optimizations
```

**Step 2**: Build with wasm-pack:

```bash
# Build for web browsers
wasm-pack build --target web --features model-server

# Build for Node.js
wasm-pack build --target nodejs --features model-server

# Build for bundlers (webpack, rollup, etc.)
wasm-pack build --target bundler --features model-server
```

This generates:
- `pkg/` directory with WASM binary and JavaScript/TypeScript bindings
- Ready-to-publish npm package

### Option 2: Using UniFFI + wasm-bindgen

**Step 1**: Build the Rust library:

```bash
cd crates/hologram-ffi

# Build for WASM target
cargo build --release --target wasm32-unknown-unknown --features model-server

# The output will be at:
# target/wasm32-unknown-unknown/release/hologram_ffi.wasm
```

**Step 2**: Generate JavaScript bindings with wasm-bindgen:

```bash
wasm-bindgen \
  --target web \
  --out-dir ./wasm-dist \
  target/wasm32-unknown-unknown/release/hologram_ffi.wasm
```

This creates:
- `wasm-dist/hologram_ffi.js` - JavaScript glue code
- `wasm-dist/hologram_ffi_bg.wasm` - WASM binary
- `wasm-dist/hologram_ffi.d.ts` - TypeScript definitions

### Option 3: UniFFI Native WASM Support

UniFFI is working on native WASM support. Once available:

```bash
# Generate WASM bindings directly from UDL
uniffi-bindgen generate \
  --library target/wasm32-unknown-unknown/release/libhologram_ffi.a \
  --language typescript-wasm \
  --out-dir ./wasm-bindings

# Or use the built-in generate-bindings tool
cargo run --bin generate-bindings -- --language typescript-wasm
```

## Size Optimization

WASM binaries can be large. Here are optimization strategies:

### 1. Compiler Optimizations

Add to `Cargo.toml`:

```toml
[profile.release]
opt-level = "z"           # Optimize for size
lto = true                # Link Time Optimization
codegen-units = 1         # Single codegen unit
panic = "abort"           # Don't include unwinding code
strip = true              # Strip symbols
```

### 2. Use `wasm-opt` for Additional Optimization

```bash
# Install binaryen tools
npm install -g binaryen

# Optimize WASM binary
wasm-opt -Oz \
  target/wasm32-unknown-unknown/release/hologram_ffi.wasm \
  -o hologram_ffi_optimized.wasm
```

Expected size reduction: 20-40%

### 3. Feature Flags for Minimal Builds

```bash
# Build without model-server (just core operations)
cargo build --release --target wasm32-unknown-unknown --no-default-features

# Build with only specific features
cargo build --release --target wasm32-unknown-unknown --features "core-ops,math-ops"
```

### 4. Split WASM Modules

For large applications, split into multiple WASM modules:

```
hologram-core.wasm      # Core operations (~500KB)
hologram-models.wasm    # Model inference (~5MB)
```

Load modules on-demand in JavaScript.

## Using WASM in the Browser

### HTML + JavaScript

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Hologram Model Server - WASM Demo</title>
</head>
<body>
    <h1>AI Model Inference in the Browser</h1>
    <div id="output"></div>

    <script type="module">
        // Import the WASM module
        import init, {
            inference_engine_create,
            inference_engine_destroy,
            model_load_bert,
            inference_generate_embedding,
        } from './pkg/hologram_ffi.js';

        async function main() {
            // Initialize WASM
            await init();
            console.log('WASM loaded successfully!');

            // Create engine
            const engineId = inference_engine_create();
            console.log(`Engine created: ${engineId}`);

            // Load model (if available in browser)
            const modelId = "bert-base";
            const modelPath = "/models/bert-base";  // Served via HTTP
            const loadResult = model_load_bert(engineId, modelId, modelPath);

            if (loadResult === 0) {
                // Generate embedding
                const text = "Hello from the browser!";
                const embeddingJson = inference_generate_embedding(
                    engineId,
                    modelId,
                    text
                );

                const embedding = JSON.parse(embeddingJson);
                console.log(`Embedding dimensions: ${embedding.length}`);

                document.getElementById('output').innerHTML = `
                    <p>Generated embedding with ${embedding.length} dimensions</p>
                    <p>First 5 values: ${embedding.slice(0, 5).join(', ')}</p>
                `;
            }

            // Cleanup
            inference_engine_destroy(engineId);
        }

        main().catch(console.error);
    </script>
</body>
</html>
```

### React Application

```tsx
import React, { useEffect, useState } from 'react';
import init, {
  inference_engine_create,
  inference_engine_destroy,
  inference_generate_embedding,
} from 'hologram-ffi-wasm';

export function EmbeddingGenerator() {
  const [engineId, setEngineId] = useState<number | null>(null);
  const [embedding, setEmbedding] = useState<number[]>([]);

  useEffect(() => {
    // Initialize WASM
    init().then(() => {
      const id = inference_engine_create();
      setEngineId(id);
    });

    // Cleanup on unmount
    return () => {
      if (engineId) {
        inference_engine_destroy(engineId);
      }
    };
  }, []);

  const generateEmbedding = async (text: string) => {
    if (!engineId) return;

    const embeddingJson = inference_generate_embedding(
      engineId,
      'bert-base',
      text
    );

    const emb = JSON.parse(embeddingJson);
    setEmbedding(emb);
  };

  return (
    <div>
      <h2>Generate Embedding</h2>
      <input
        type="text"
        onBlur={(e) => generateEmbedding(e.target.value)}
        placeholder="Enter text..."
      />
      {embedding.length > 0 && (
        <p>Embedding: {embedding.length} dimensions</p>
      )}
    </div>
  );
}
```

## Using WASM in Node.js

```javascript
const { readFileSync } = require('fs');
const { join } = require('path');

// Load WASM module
const wasmPath = join(__dirname, 'hologram_ffi_bg.wasm');
const wasmBuffer = readFileSync(wasmPath);

// Import bindings
const {
  inference_engine_create,
  inference_engine_destroy,
  inference_generate_embedding,
} = require('./hologram_ffi');

async function main() {
  // Initialize WASM
  const { instance } = await WebAssembly.instantiate(wasmBuffer, {
    /* imports */
  });

  // Create engine
  const engineId = inference_engine_create();
  console.log(`Engine ID: ${engineId}`);

  // Generate embedding
  const text = "Hello from Node.js!";
  const embeddingJson = inference_generate_embedding(
    engineId,
    "model-id",
    text
  );

  const embedding = JSON.parse(embeddingJson);
  console.log(`Embedding dimensions: ${embedding.length}`);

  // Cleanup
  inference_engine_destroy(engineId);
}

main().catch(console.error);
```

## Serving Model Files

Models need to be accessible to the WASM module. Options:

### Option 1: Bundle Small Models

For small models (<10MB), bundle with your app:

```bash
# Copy model files to public directory
cp -r /models/bert-base public/models/

# Reference in code
const modelPath = "/models/bert-base";
```

### Option 2: Lazy Load from CDN

For large models, load on-demand from a CDN:

```javascript
async function loadModel(modelId) {
  const response = await fetch(`https://cdn.example.com/models/${modelId}.bin`);
  const arrayBuffer = await response.arrayBuffer();

  // Load into WASM memory
  // Implementation depends on your FFI design
}
```

### Option 3: IndexedDB Caching

Cache models in browser storage:

```javascript
async function loadModelWithCache(modelId, modelUrl) {
  // Open IndexedDB
  const db = await openDB('hologram-models', 1, {
    upgrade(db) {
      db.createObjectStore('models');
    },
  });

  // Check cache
  let modelData = await db.get('models', modelId);

  if (!modelData) {
    // Download and cache
    const response = await fetch(modelUrl);
    modelData = await response.arrayBuffer();
    await db.put('models', modelData, modelId);
  }

  return modelData;
}
```

## Performance Considerations

### 1. Memory Management

WASM has a linear memory model. Monitor memory usage:

```javascript
// Check WASM memory usage
const memory = instance.exports.memory;
console.log(`Memory size: ${memory.buffer.byteLength} bytes`);

// Grow memory if needed (in 64KB pages)
memory.grow(100); // Add 6.4MB
```

### 2. Threading (Future)

WASM threading is experimental but supported in some browsers:

```toml
[dependencies]
wasm-bindgen-rayon = "1.0"  # For web workers
```

### 3. SIMD (Future)

WebAssembly SIMD can accelerate math operations:

```bash
# Build with SIMD support
RUSTFLAGS="-C target-feature=+simd128" \
  cargo build --release --target wasm32-unknown-unknown
```

## Debugging WASM

### Browser DevTools

```javascript
// Enable WASM debugging
console.log = (...args) => {
  console.info('[WASM]', ...args);
};

// Set breakpoints in browser DevTools (Sources tab)
```

### wasm-objdump

```bash
# Inspect WASM binary
wasm-objdump -x target/wasm32-unknown-unknown/release/hologram_ffi.wasm

# Disassemble
wasm-objdump -d target/wasm32-unknown-unknown/release/hologram_ffi.wasm
```

## Deployment Checklist

- [ ] Build WASM with optimizations (`--release`, `opt-level = "z"`)
- [ ] Run `wasm-opt` for additional size reduction
- [ ] Generate JavaScript bindings with `wasm-bindgen`
- [ ] Test in target browsers (Chrome, Firefox, Safari, Edge)
- [ ] Set up CORS headers for model file serving
- [ ] Implement model caching (IndexedDB or Service Worker)
- [ ] Add loading indicators for WASM initialization
- [ ] Monitor memory usage and handle errors gracefully
- [ ] Set up CDN for WASM and model files
- [ ] Add compression (gzip/brotli) for WASM files

## Browser Compatibility

| Browser | WASM Support | SIMD | Threads |
|---------|--------------|------|---------|
| Chrome 91+ | ✅ | ✅ | ✅ |
| Firefox 89+ | ✅ | ✅ | ✅ |
| Safari 15+ | ✅ | ✅ | ❌ |
| Edge 91+ | ✅ | ✅ | ✅ |

## Example Projects

See `/docs/examples/` for complete examples:

- `typescript_model_server_usage.ts` - TypeScript/WASM usage
- `python_model_server_usage.py` - Python comparison

## Troubleshooting

### "RuntimeError: memory access out of bounds"

Increase WASM memory:

```toml
[target.wasm32-unknown-unknown]
rustflags = ["-C", "link-args=-z stack-size=1048576"]
```

### "Module not found" errors

Ensure proper import paths:

```javascript
// Wrong
import init from 'hologram_ffi';

// Correct
import init from './pkg/hologram_ffi.js';
```

### Large binary size

- Enable LTO and size optimizations
- Run `wasm-opt -Oz`
- Split into multiple modules
- Use feature flags to exclude unused code

## Next Steps

1. Implement streaming for large model loading
2. Add Web Workers for background processing
3. Implement model quantization for smaller sizes
4. Create npm package for easy distribution
5. Build demo applications showcasing WASM capabilities

## Resources

- [WebAssembly.org](https://webassembly.org/)
- [wasm-bindgen Book](https://rustwasm.github.io/wasm-bindgen/)
- [UniFFI Documentation](https://mozilla.github.io/uniffi-rs/)
- [Rust WASM Book](https://rustwasm.github.io/docs/book/)
