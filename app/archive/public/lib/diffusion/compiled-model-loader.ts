'use client';

/**
 * Compiled Model Loader for Hologram-ONNX
 *
 * Loads precompiled .bin models using Phase 5/6 walker execution runtime.
 * This replaces the old ONNX protobuf parsing with fast binary loading.
 */

// WASM module types (will be generated by wasm-bindgen)
// We use dynamic imports to load the WASM module at runtime
type WasmModule = typeof import('@/lib/onnx/hologram_onnx');
type WasmCompiledModel = import('@/lib/onnx/hologram_onnx').WasmCompiledModel;

// Cache the WASM module after first load
let wasmModule: WasmModule | null = null;

/**
 * Load the WASM module dynamically
 */
async function loadWasmModule(): Promise<WasmModule> {
  if (wasmModule) {
    return wasmModule;
  }

  try {
    // @ts-ignore - WASM module generated at build time
    // Use TypeScript path alias (client-side only, so no SSR issues)
    wasmModule = await import('@/lib/onnx/hologram_onnx');

    // Verify the module loaded correctly
    if (!wasmModule) {
      throw new Error('WASM module loaded but is null/undefined');
    }

    // CRITICAL: Initialize the WASM module by calling the default export
    // This sets up the internal `wasm` variable that all exported functions use
    if (typeof wasmModule.default === 'function') {
      console.log('[WASM] Initializing WASM module...');
      await wasmModule.default();
      console.log('[WASM] WASM module initialized');
    } else {
      throw new Error('WASM module missing default initialization function');
    }

    if (typeof wasmModule.init_onnx_webgpu !== 'function') {
      console.error('WASM module keys:', Object.keys(wasmModule));
      console.error('WASM module:', wasmModule);
      throw new Error('WASM module missing init_onnx_webgpu function');
    }

    console.log('[WASM] Module loaded successfully');
    return wasmModule;
  } catch (error) {
    console.error('[WASM] Failed to load module:', error);
    throw new Error(`Failed to load WASM module: ${error}`);
  }
}

export interface CompiledModelConfig {
  modelPath: string;         // Path to .bin file
  weightsPath?: string;       // Optional path to .safetensors file
  cacheKey: string;           // IndexedDB cache key
  version: string;            // Version for cache invalidation
}

export interface ModelLoadProgress {
  stage: 'fetching_model' | 'fetching_weights' | 'loading' | 'initializing' | 'ready';
  bytesLoaded?: number;
  bytesTotal?: number;
  percentage?: number;
  message?: string;  // Optional detailed status message
}

export type ProgressCallback = (progress: ModelLoadProgress) => void;

/**
 * Load a compiled model with caching
 *
 * This function:
 * 1. Checks IndexedDB cache for model and weights
 * 2. Fetches missing data via HTTP
 * 3. Caches data for future use
 * 4. Initializes WasmCompiledModel with binary data
 * 5. Returns ready-to-use model
 */
export async function loadCompiledModel(
  config: CompiledModelConfig,
  onProgress?: ProgressCallback
): Promise<WasmCompiledModel> {
  // Load WASM module dynamically
  const wasm = await loadWasmModule();

  // Initialize WebGPU backend
  await wasm.init_onnx_webgpu();

  // Open IndexedDB for caching
  const db = await openModelCache();

  // Load model binary
  onProgress?.({ stage: 'fetching_model', percentage: 0 });
  const modelBytes = await loadCachedOrFetch(
    db,
    `${config.cacheKey}-model-${config.version}`,
    config.modelPath,
    (loaded, total) => {
      onProgress?.({
        stage: 'fetching_model',
        bytesLoaded: loaded,
        bytesTotal: total,
        percentage: total > 0 ? (loaded / total) * 100 : 0,
      });
    }
  );

  // Load weights binary (optional)
  let weightsBytes: Uint8Array | null = null;
  if (config.weightsPath) {
    onProgress?.({ stage: 'fetching_weights', percentage: 0 });
    weightsBytes = await loadCachedOrFetch(
      db,
      `${config.cacheKey}-weights-${config.version}`,
      config.weightsPath,
      (loaded, total) => {
        onProgress?.({
          stage: 'fetching_weights',
          bytesLoaded: loaded,
          bytesTotal: total,
          percentage: total > 0 ? (loaded / total) * 100 : 0,
        });
      }
    );
  }

  // Deserialize model from binary
  onProgress?.({
    stage: 'loading',
    percentage: 50,
    message: `Loading compiled model from binary (${modelBytes.length.toLocaleString()} bytes)...`
  });
  const model = wasm.WasmCompiledModel.fromBinary(
    modelBytes,
    weightsBytes ?? undefined
  );

  // Initialize WebGPU executor
  onProgress?.({
    stage: 'initializing',
    percentage: 75,
    message: 'Initializing WebGPU executor...'
  });
  await model.initialize();

  onProgress?.({ stage: 'ready', percentage: 100 });

  return model;
}

/**
 * Clear compiled model cache
 */
export async function clearCompiledModelCache(): Promise<void> {
  return new Promise((resolve, reject) => {
    const request = indexedDB.deleteDatabase('hologram-models');
    request.onsuccess = () => {
      console.log('[Compiled Cache] Cleared all compiled models');
      resolve();
    };
    request.onerror = () => reject(request.error);
  });
}

/**
 * Get compiled model cache statistics
 */
export async function getCompiledModelCacheStats(): Promise<{ totalSize: number; itemCount: number }> {
  try {
    const db = await openModelCache();
    const tx = db.transaction('models', 'readonly');
    const store = tx.objectStore('models');
    const getAllRequest = store.getAllKeys();

    return new Promise((resolve, reject) => {
      getAllRequest.onsuccess = async () => {
        const keys = getAllRequest.result;
        let totalSize = 0;

        // Get size of each cached item
        for (const key of keys) {
          const getRequest = store.get(key);
          await new Promise<void>((resolveGet) => {
            getRequest.onsuccess = () => {
              const data = getRequest.result;
              if (data instanceof Uint8Array) {
                totalSize += data.byteLength;
              } else if (data?.byteLength) {
                totalSize += data.byteLength;
              }
              resolveGet();
            };
            getRequest.onerror = () => resolveGet();
          });
        }

        db.close();
        resolve({ totalSize, itemCount: keys.length });
      };
      getAllRequest.onerror = () => {
        db.close();
        reject(getAllRequest.error);
      };
    });
  } catch (error) {
    console.warn('[Compiled Cache] Failed to get stats:', error);
    return { totalSize: 0, itemCount: 0 };
  }
}

/**
 * Open IndexedDB for model caching
 */
async function openModelCache(): Promise<IDBDatabase> {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('hologram-models', 1);

    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);

    request.onupgradeneeded = (event) => {
      const db = (event.target as IDBOpenDBRequest).result;
      if (!db.objectStoreNames.contains('models')) {
        db.createObjectStore('models');
      }
    };
  });
}

/**
 * Load data from cache or fetch from URL
 */
async function loadCachedOrFetch(
  db: IDBDatabase,
  cacheKey: string,
  url: string,
  onProgress?: (loaded: number, total: number) => void
): Promise<Uint8Array> {
  // Try cache first
  const cached = await getCached(db, cacheKey);
  if (cached) {
    console.log(`[Cache] Hit: ${cacheKey}`);
    return cached;
  }

  console.log(`[Cache] Miss: ${cacheKey}, fetching from ${url}`);

  // Fetch from URL
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed to fetch ${url}: ${response.status}`);
  }

  const contentLength = parseInt(response.headers.get('Content-Length') || '0', 10);
  const reader = response.body?.getReader();
  if (!reader) {
    throw new Error('Failed to get response reader');
  }

  const chunks: Uint8Array[] = [];
  let bytesLoaded = 0;

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;

    chunks.push(value);
    bytesLoaded += value.length;
    onProgress?.(bytesLoaded, contentLength);
  }

  // Concatenate chunks
  const data = new Uint8Array(bytesLoaded);
  let offset = 0;
  for (const chunk of chunks) {
    data.set(chunk, offset);
    offset += chunk.length;
  }

  // Cache for future use
  await putCached(db, cacheKey, data);

  return data;
}

/**
 * Get data from IndexedDB cache
 */
async function getCached(db: IDBDatabase, key: string): Promise<Uint8Array | null> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['models'], 'readonly');
    const store = transaction.objectStore('models');
    const request = store.get(key);

    request.onerror = () => reject(request.error);
    request.onsuccess = () => {
      const result = request.result;
      resolve(result ? new Uint8Array(result) : null);
    };
  });
}

/**
 * Put data into IndexedDB cache
 */
async function putCached(db: IDBDatabase, key: string, data: Uint8Array): Promise<void> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['models'], 'readwrite');
    const store = transaction.objectStore('models');
    const request = store.put(data, key);

    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve();
  });
}
